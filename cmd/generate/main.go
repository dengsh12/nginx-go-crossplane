package main

//go:generate go run main.go --func=generate --source_name=lua
//go:generate go run main.go --func=generate --source_name=headersMore
//go:generate go run main.go  --func=generate --source_name=njs
//go:generate go run main.go --func=generate --source_name=otel
//go:generate go run main.go --func=generate --source_name=OSS

import (
	"flag"
	"fmt"
	"html/template"
	"os"
	"time"

	"github.com/nginxinc/nginx-go-crossplane/internal/generator"
)

type directiveMapFileTemplate struct {
	fileHead        []string
	directiveMap    map[string][][]string
	mapVariableName string
	matchFnName     string
	lineSep         string
}

func (template *directiveMapFileTemplate) init(dirctiveMap map[string][][]string, mapVariableName string, mathFnName string) {
	template.lineSep = "\n"
	contents := make([]string, 0)
	contents = append(contents, "/**")
	contents = append(contents, " * Copyright (c) F5, Inc.")
	contents = append(contents, " *")
	contents = append(contents, " * This source code is licensed under the Apache License, Version 2.0 license found in the")
	contents = append(contents, " * LICENSE file in the root directory of this source tree.")
	contents = append(contents, " */")
	contents = append(contents, "")
	contents = append(contents, "// Code generated by generator; DO NOT EDIT.")
	contents = append(contents, "// If you want to overwrite any directive's definition, please modify directive_overrides.go")
	contents = append(contents, "// All the definitions are generated from the source code")
	contents = append(contents, "// Each bit mask describes these behaviors:")
	contents = append(contents, "//   - how many arguments the directive can take")
	contents = append(contents, "//   - whether or not it is a block directive")
	contents = append(contents, "//   - whether this is a flag (takes one argument that's either \"on\" or \"off\")")
	contents = append(contents, "//   - which contexts it's allowed to be in")
	contents = append(contents, "")

	// Package definition
	contents = append(contents, "package crossplane")
	contents = append(contents, "")

	contents = append(contents, "//nolint:gochecknoglobals")
}

// todo: delete this
func testRun() {
	testMap := map[string][][]string{
		"absolute_redirect": {
			[]string{"ngxHTTPMainConf", "ngxHTTPSrvConf", "ngxHTTPLocConf", "ngxConfFlag"},
			[]string{"ngxHTTPMainConf", "ngxHTTPLocConf", "ngxConfFlag"},
		},
		"autoindex": {
			[]string{"ngxHTTPMainConf", "ngxHTTPSrvConf", "ngxHTTPLocConf", "ngxConfFlag"},
		},
	}
	const tmpl = `
	{{- range _, line := .fileHead}}
	fileHead
	{{end}}
var xxx = map[string][][]uint{
{{- range $directiveName, $bitmaskNamesList := .directiveMap}}
    {{$directiveName}}: {
        {{- range $outerIndex, $bitmaskNames := $bitmaskNamesList}}
		{{- "\n"}}
        {{- range $innerIndex, $bitmaskName := $bitmaskNames}}
            {{- if $innerIndex}}|{{end}}{{$bitmaskName}}
        {{- end}},
        {{- end}}
    },
{{- end }}
}
`

	t := template.Must(template.New("mapTemplate").Parse(tmpl))
	err := t.Execute(os.Stdout, testMap)
	if err != nil {
		panic(err)
	}
}

func main() {
	// testRun()
	// return
	start_t := time.Now()
	var (
		function           = flag.String("func", "", "the function you need, should be code2map, code2json, generate, or json2map (required)")
		sourceCodePath     = flag.String("source_code", "", "the folder includes the source code your want to generate support from (required when func=code2map or code2json)")
		_                  = flag.String("json_file", "", "the folder of the json file you want to generate support from (required when func=json2map)")
		sourceName         = flag.String("source_name", "", "OSS, NPLUS, or the name of the module(required)")
		outputFolder       = flag.String("output_folder", "./tmp", "the folder at which the generated support file locates, ./tmp by default(optional)")
		onlyDocumentedDirs = flag.Bool("documented_only", false, "only output consider directives on https://nginx.org/en/docs/dirindex.html, optional, false by default")
	)
	flag.Parse()
	generator.Generate(*function, *sourceName, *onlyDocumentedDirs, *sourceCodePath, *outputFolder)
	fmt.Println("use time:" + time.Since(start_t).String())
}
